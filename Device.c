/*++

Module Name:

    device.c - Device handling events for example driver.

Abstract:

   This file contains the device entry points and callbacks.
    
Environment:

    Kernel-mode Driver Framework

--*/

//VERY GOOD!!!
//https://learn.microsoft.com/en-us/windows-hardware/drivers/usbcon/understanding-the-kmdf-template-code-for-usb#driver-source-code

#include "driver.h"
#include "reports.h"
#include "device.tmh"

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, VHIDCreateDevice)
#pragma alloc_text (PAGE, VHIDEvtDevicePrepareHardware)
#pragma alloc_text (PAGE, VHIDEvtDeviceD0Entry)
#pragma alloc_text (PAGE, VHIDEvtDeviceD0Exit)
//#pragma alloc_text (PAGE, VHIDEvtUsbTargetPipeReadComplete) //no!
#pragma alloc_text (PAGE, VHIDEvtDeviceContextCleanup)
//#pragma alloc_text (PAGE, VHIDEvtVhfAsyncOperation)
#endif


NTSTATUS
VHIDCreateDevice(
    _Inout_ PWDFDEVICE_INIT DeviceInit
    )
/*++

Routine Description:

    Worker routine called to create a device and its software resources.

Arguments:

    DeviceInit - Pointer to an opaque init structure. Memory for this
                    structure will be freed by the framework when the WdfDeviceCreate
                    succeeds. So don't access the structure after that point.

Return Value:

    NTSTATUS

--*/
{
    WDF_PNPPOWER_EVENT_CALLBACKS pnpPowerCallbacks;
    WDF_OBJECT_ATTRIBUTES   deviceAttributes;
    PDEVICE_CONTEXT deviceContext;
    WDFDEVICE device;
    NTSTATUS status;

    PAGED_CODE();

    //__int3();

    WDF_PNPPOWER_EVENT_CALLBACKS_INIT(&pnpPowerCallbacks);
    pnpPowerCallbacks.EvtDevicePrepareHardware = VHIDEvtDevicePrepareHardware;
    pnpPowerCallbacks.EvtDeviceD0Entry = VHIDEvtDeviceD0Entry;
    pnpPowerCallbacks.EvtDeviceD0Exit = VHIDEvtDeviceD0Exit;
    WdfDeviceInitSetPnpPowerEventCallbacks(DeviceInit, &pnpPowerCallbacks);
    
    WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE(&deviceAttributes, DEVICE_CONTEXT);
    deviceAttributes.EvtCleanupCallback = VHIDEvtDeviceContextCleanup;
    status = WdfDeviceCreate(&DeviceInit, &deviceAttributes, &device);

    if (NT_SUCCESS(status)) {
        //
        // Get a pointer to the device context structure that we just associated
        // with the device object. We define this structure in the device.h
        // header file. DeviceGetContext is an inline function generated by
        // using the WDF_DECLARE_CONTEXT_TYPE_WITH_NAME macro in device.h.
        // This function will do the type checking and return the device context.
        // If you pass a wrong object handle it will return NULL and assert if
        // run under framework verifier mode.
        //
        deviceContext = DeviceGetContext(device);

        //
        // Initialize the context.
        //
        //deviceContext->PrivateDeviceData = 0;

        //deviceContext->VhfHidReportPacket.reportBuffer = deviceContext->VhfHidData;
        //deviceContext->VhfHidReportPacket.reportBufferLen = GAMEPAD_REPORT_SIZE;

        deviceContext->VhfGamepadReportPacket.reportBuffer = deviceContext->VhfGamepadReport;
        deviceContext->VhfGamepadReportPacket.reportBufferLen = GAMEPAD_REPORT_SIZE;

        deviceContext->VhfMouseReportPacket.reportBuffer = deviceContext->VhfMouseReport;
        deviceContext->VhfMouseReportPacket.reportBufferLen = MOUSE_REPORT_SIZE;

        deviceContext->VhfKeyboardReportPacket.reportBuffer = deviceContext->VhfKeyboardReport;
        deviceContext->VhfKeyboardReportPacket.reportBufferLen = KEYBOARD_REPORT_SIZE;

        //
        // Create a device interface so that applications can find and talk
        // to us.
        //
        status = WdfDeviceCreateDeviceInterface(
            device,
            &GUID_DEVINTERFACE_VirtualHIDivinations,
            NULL // ReferenceString //
            );

        if (NT_SUCCESS(status)) {
            //
            // Initialize the I/O Package and any Queues
            //
            status = VHIDQueueInitialize(device);
        }

        VHF_CONFIG config;

        PDEVICE_OBJECT obj = WdfDeviceWdmGetDeviceObject(device);
        /*
        unsigned int szr[] = {
            0x10, 0x20, 0x30, 0x40, 0x50
        };
        print(sizeof(szr) << ", " << ARRAYSIZE(szr)); //output: 20, 5
        */

        //lowkey i could use sizeof here since the array is made of elements that are only 1 byte in size
        //wait a second i think i was supposed to use sizeof
        VHF_CONFIG_INIT(&config, obj, sizeof(fullReportDescriptor), fullReportDescriptor);
        config.VendorID = 0x289b;
        config.ProductID = 0x0080;
        config.VersionNumber = 2;
        //config.EvtVhfAsyncOperationWriteReport = VHIDEvtVhfAsyncOperation

        //should be called a PASSIVE_LEVEL but wtf does that mean? (chat i know what that means now)
        status = VhfCreate(&config, &deviceContext->VhfHandle);
        if (!NT_SUCCESS(status)) {
            TraceEvents(TRACE_LEVEL_ERROR, TRACE_DEVICE, "VhfCreate failed %!STATUS!", status);
            KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "VHID: VhfCreate failed 0x%x\n", status));
            return status;
        }

        status = VhfStart(deviceContext->VhfHandle);
        if (!NT_SUCCESS(status)) {
            TraceEvents(TRACE_LEVEL_ERROR, TRACE_DEVICE, "VhfStart failed %!STATUS!", status);
            KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "VHID: VhfStart failed 0x%x\n", status));
        }
    }

    return status;
}

NTSTATUS
VHIDEvtDevicePrepareHardware(
    _In_ WDFDEVICE Device,
    _In_ WDFCMRESLIST ResourceList,
    _In_ WDFCMRESLIST ResourceListTranslated
    )
/*++

Routine Description:

    In this callback, the driver does whatever is necessary to make the
    hardware ready to use.  In the case of a USB device, this involves
    reading and selecting descriptors.

Arguments:

    Device - handle to a device

Return Value:

    NT status value

--*/
{
    NTSTATUS status;
    PDEVICE_CONTEXT pDeviceContext;
    WDF_USB_DEVICE_CREATE_CONFIG createParams;
    WDF_USB_DEVICE_SELECT_CONFIG_PARAMS configParams;
    WDF_USB_CONTINUOUS_READER_CONFIG    readerConfig;

    UNREFERENCED_PARAMETER(ResourceList);
    UNREFERENCED_PARAMETER(ResourceListTranslated);

    PAGED_CODE();

    //__int3();

    TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "%!FUNC! Entry");
    KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "VHID: Prepare hardware!\n"));

    status = STATUS_SUCCESS;
    pDeviceContext = DeviceGetContext(Device);

    //
    // Create a USB device handle so that we can communicate with the
    // underlying USB stack. The WDFUSBDEVICE handle is used to query,
    // configure, and manage all aspects of the USB device.
    // These aspects include device properties, bus properties,
    // and I/O creation and synchronization. We only create the device the first time
    // PrepareHardware is called. If the device is restarted by pnp manager
    // for resource rebalance, we will use the same device handle but then select
    // the interfaces again because the USB stack could reconfigure the device on
    // restart.
    //
    if (pDeviceContext->UsbDevice == NULL) {

        //
        // Specifying a client contract version of 602 enables us to query for
        // and use the new capabilities of the USB driver stack for Windows 8.
        // It also implies that we conform to rules mentioned in MSDN
        // documentation for WdfUsbTargetDeviceCreateWithParameters.
        //
#define STRING2(x) #x
#define STRING(x) STRING2(x)
        //this wasn't a problem lol
#pragma message("RAPHNET ADAPTER DOESN'T DO USB 3.0 SO MAYBE IF IT DOESN'T WORK I GOTTA CHANGE TS ON LINE " STRING(__LINE__))
        WDF_USB_DEVICE_CREATE_CONFIG_INIT(&createParams,
                                         USBD_CLIENT_CONTRACT_VERSION_602
                                         );

        status = WdfUsbTargetDeviceCreateWithParameters(Device,
                                                    &createParams,
                                                    WDF_NO_OBJECT_ATTRIBUTES,
                                                    &pDeviceContext->UsbDevice
                                                    );

        if (!NT_SUCCESS(status)) {
            TraceEvents(TRACE_LEVEL_ERROR, TRACE_DEVICE,
                        "WdfUsbTargetDeviceCreateWithParameters failed 0x%x", status);
            KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "VHID: WdfUsbTargetDeviceCreateWithParameters failed 0x%x\n", status));
            return status;
        }
    }

    //
    // Select the first configuration of the device, using the first alternate
    // setting of each interface
    //
    WDF_USB_DEVICE_SELECT_CONFIG_PARAMS_INIT_MULTIPLE_INTERFACES(&configParams,
                                                                 0,
                                                                 NULL
                                                                 );

    status = WdfUsbTargetDeviceSelectConfig(pDeviceContext->UsbDevice,
                                            WDF_NO_OBJECT_ATTRIBUTES,
                                            &configParams
                                            );

    if (!NT_SUCCESS(status)) {
        TraceEvents(TRACE_LEVEL_ERROR, TRACE_DEVICE,
                    "WdfUsbTargetDeviceSelectConfig failed 0x%x", status);
        KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "VHID: WdfUsbTargetDeviceSelectConfig failed 0x%x\n", status));
        return status;
    }

    //now we gotta open them pipes
    pDeviceContext->UsbInterface = WdfUsbTargetDeviceGetInterface(pDeviceContext->UsbDevice, 0);
    if (pDeviceContext->UsbInterface == WDF_NO_HANDLE) {
        KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "VHID: WdfUsbTargetDeviceGetInterface failed?\n"));
    }
    else {
        WDF_USB_PIPE_INFORMATION info;
        WDF_USB_PIPE_INFORMATION_INIT(&info);
        pDeviceContext->UsbPipe = WdfUsbInterfaceGetConfiguredPipe(pDeviceContext->UsbInterface, 0, &info);
        if (pDeviceContext->UsbPipe == WDF_NO_HANDLE) {
            KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "VHID: WdfUsbInterfaceGetConfiguredPipe failed?\n"));
        }
        //WdfUsbTargetPipeSetNoMaximumPacketSizeCheck(pDeviceContext->UsbPipe);
        WDF_USB_CONTINUOUS_READER_CONFIG_INIT(&readerConfig, VHIDEvtUsbTargetPipeReadComplete, (WDFCONTEXT)pDeviceContext, info.MaximumPacketSize); //according to uhhh
        pDeviceContext->resHeaderLength = readerConfig.HeaderLength;
        status = WdfUsbTargetPipeConfigContinuousReader(pDeviceContext->UsbPipe, &readerConfig);
        if (!NT_SUCCESS(status)) {
            KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "VHID: WdfUsbTargetPipeConfigContinuousReader failed 0x%x!\n", status));
        }
    }

    TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "%!FUNC! Exit");
    KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "VHID: PrepareHardware Exit %!FUNC!\n"));

    return status;
}

//void 
//VHIDEvtVhfAsyncOperation(
//    _In_ PVOID VhfClientContext,
//    _In_ VHFOPERATIONHANDLE VhfOperationHandle,
//    _In_opt_ PVOID VhfOperationContext,
//    _In_ PHID_XFER_PACKET HidTransferPacket
//    ) {
//    NTSTATUS status;
// 
//    PAGED_CODE();
// 
//    VhfAsyncOperationComplete(VhfOperationHandle, status);
//}

NTSTATUS VHIDEvtDeviceD0Entry(
    _In_ WDFDEVICE Device,
    _In_ WDF_POWER_DEVICE_STATE PreviousState
) {
    UNREFERENCED_PARAMETER(PreviousState);

    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_CONTEXT pDeviceContext;
    WDFIOTARGET ioTarget;

    PAGED_CODE()

    //__int3();

    pDeviceContext = DeviceGetContext(Device);
    if (pDeviceContext->UsbPipe != WDF_NO_HANDLE) {
        ioTarget = WdfUsbTargetPipeGetIoTarget(pDeviceContext->UsbPipe);
        status = WdfIoTargetStart(ioTarget);
        if (!NT_SUCCESS(status)) {
            KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "VHID: WdfIoTargetStart failed 0x%x!\n", status));
        }
    }

    return status;
}

NTSTATUS VHIDEvtDeviceD0Exit(
    _In_ WDFDEVICE Device,
    _In_ WDF_POWER_DEVICE_STATE TargetState
) {
    UNREFERENCED_PARAMETER(TargetState);

    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_CONTEXT pDeviceContext;
    WDFIOTARGET ioTarget;

    PAGED_CODE()
    
    //__int3();

    pDeviceContext = DeviceGetContext(Device);
    if (pDeviceContext->UsbPipe != WDF_NO_HANDLE) {
        ioTarget = WdfUsbTargetPipeGetIoTarget(pDeviceContext->UsbPipe); //https://learn.microsoft.com/en-us/windows-hardware/drivers/wdf/working-with-usb-pipes#reading-from-a-pipe
        WdfIoTargetStop(ioTarget, WdfIoTargetWaitForSentIoToComplete);
        //https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdfiotarget/ne-wdfiotarget-_wdf_io_target_sent_io_action
    }

    return status;
}

//#define WORD_TO_BINARY_PATTERN "0b%c%c%c%c%c%c%c%c|0b%c%c%c%c%c%c%c%c"
//#define WORD_TO_BINARY(word)  \
//  ((word) & 0x8000 ? '1' : '0'), \
//  ((word) & 0x4000 ? '1' : '0'), \
//  ((word) & 0x2000 ? '1' : '0'), \
//  ((word) & 0x1000 ? '1' : '0'), \
//  ((word) & 0x800 ? '1' : '0'),  \
//  ((word) & 0x400 ? '1' : '0'),  \
//  ((word) & 0x200 ? '1' : '0'),  \
//  ((word) & 0x100 ? '1' : '0'),  \
//  ((word) & 0x80 ? '1' : '0'),   \
//  ((word) & 0x40 ? '1' : '0'),   \
//  ((word) & 0x20 ? '1' : '0'),   \
//  ((word) & 0x10 ? '1' : '0'),   \
//  ((word) & 0x08 ? '1' : '0'),   \
//  ((word) & 0x04 ? '1' : '0'),   \
//  ((word) & 0x02 ? '1' : '0'),   \
//  ((word) & 0x01 ? '1' : '0') 

NTSTATUS
PrepareGamepadReport(PDEVICE_CONTEXT pDeviceContext, PGAMEPAD_REPORT report) {
    //https://godbolt.org/z/5o5WK9cP8
    //https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAMzwBtMA7AQwFtMQByARg9KtQYEAysib0QXACx8BBAKoBnTAAUAHpwAMvAFYTStJg1DIApACYAQuYukl9ZATwDKjdAGFUtAK4sGEgOykrgAyeAyYAHI%2BAEaYxCCBAA6oCoRODB7evgGkyamOAqHhUSyx8YF2mA7pQgRMxASZPn5cFZj2BQy19QRFkTFxCbZ1DU3ZrcM9fSVlCQCUtqhexMjsHOYAzGHI3lgA1CYbbk4KBMSYrIfYJhoAgje3XqlGe8xsColMq3un6IdWdwemywNHCe0SxDCBAgLAUwDmezQXgIByOhzce1hwFRbnRe1ctCBdwIAE9EpgQT8zl4HAd/ADbnsmXsvAxUsBwug9rQBNieS9VP8HsyWWy8ByKdzeVKXiShYD/AARPaK24AFVupD2ACplKqNfL7ndTsQaSjUNFtHSGSL9Yy/hsbczWezOTK%2BdLEgZVghPFhiIaTErA3coZimGEIAig06mRbtNq9ktiAoEIRUcrwgB3JOWw0i5OpwgAWiuXq%2BmF9tH9Gb2GnzzOFzrFEq5/I9L3qAYArFZu8rDgP6U2RUyAJykEejrj1u4ioOKhtMvXqxkki4IWsQFcauZdpfgyGCCDmMzrpibxLoJh1EAHMxmHF488IUsbbCqJ9He%2BP09fjEvm%2B2AknMB6FmmBBAVyg46i%2BB77r2XAmP2tZmEhjpThCUIQOBJZlt6lZ%2BnEoEYXOzJYce5gAGy4ZBVzoCRsaHthXaMZhR7QrRUEAHSqGxZFMhRnHLEWdHvug3EgQeQkQAhFj1v2/GMuRHGycQPYWEhinSapp4vuC163j%2B/57IBVyfuieJ/tZaLfmZ75SaRylMucBDLAwdaBkqHALLQnDdrwfgcFopCoJwuKWNYPzJt8mw8KQBCaD5CwANYgBsGzcRl2U5blVH6JwkiBUloWcLwCggBoCVJQscCwEgaAsIkdBxOQlCNc19DxAAbsgiSJAA%2Bt1XBjgNBgEJgpwDaoVHSDQtATSmlDRCV0RhPUJKcPFa3MMQJIAPKWlUiXcLwjVsII%2B0MLQm3BbwWDRF4wBuGItAVadpBYCwhjAOId2fXg5zVN1k0lZgqhVMiawhVC7QlbQeDRMQG0eFgJVnHgLBbbwIPENEKSYIqmDfUYCNGDVfAGMACgAGp4JgWb7eSQXxfwggiGI7BSDIgiKCo6j/boXD6D9KDWNY%2BiIxVkALKgiSdO9vCoLjkJYNLUa2O0x3pC4DDuJ4zR6CEYT9KUgzC3kaQCGMLS5CkVsMNMAzxMLlTVAI3SjAb4yax0NQjL0JszObkxe1ktunFMQfOxICwKDFXO%2Bf5xX/WFHB7DNkiYgovV7MNY7ceNk0ohAuCECQ94bFwcy8CdWhzKl6WZblLfZflfkcEVpBBSFaflZV1V3bVMCICASwEIkyJtRAHUtcQESsGsmfZ7n%2BeFzexe8BS5eq3obPCKI4jc/vfNqCVQukFmyOJNjSccAF3clWn%2B3IpP5pUBns0r8gecjevE2nD2BADwTU56V2rrXGqjcMpZVbi3AqncU69zKrYAeddkoILMEgpWKD0EN1ILjVIzhJBAA%3D%3D%3D
    //volatile UCHAR reportId = 1;
    //pDeviceContext->VhfHidReport = *report; //wait this is valid right? (yes. it makes a copy.)
    memcpy(&pDeviceContext->VhfGamepadReport, report, GAMEPAD_REPORT_SIZE);
    //pDeviceContext->VhfHidReportPacket.reportBufferLen = GAMEPAD_REPORT_SIZE;
    //pDeviceContext->VhfHidReportPacket.reportId = reportId; //?
    return VhfReadReportSubmit(pDeviceContext->VhfHandle, &pDeviceContext->VhfGamepadReportPacket);
}

NTSTATUS
PrepareMouseReport(PDEVICE_CONTEXT pDeviceContext, PGAMEPAD_REPORT report) {
    //volatile UCHAR reportId = 2;

    MOUSE_REPORT vhfReport;
    volatile float calculatedX = ((report->x - 16000) / 16000.f) * SENSITIVITY;
    volatile float calculatedY = ((report->y - 16000) / 16000.f) * SENSITIVITY;
    vhfReport.id = 2;
    vhfReport.x = (char)calculatedX;
    vhfReport.y = (char)calculatedY;
    //vhfReport.buttons = ((report->buttons >> 8) & 1) << 7; //checking the 9th bit of buttons (which would be the first bit of the upper WORD)
    //vhfReport.buttons = (report->buttons & 1) << 7; //checking the 9th bit of buttons (which would be the first bit of the upper WORD)
    vhfReport.buttons = (BYTE)report->buttons;
    memcpy(&pDeviceContext->VhfMouseReport, &vhfReport, MOUSE_REPORT_SIZE); //erm...
    //pDeviceContext->VhfHidReportPacket.reportBufferLen = MOUSE_REPORT_SIZE;
    //pDeviceContext->VhfHidReportPacket.reportId = reportId; //?
    return VhfReadReportSubmit(pDeviceContext->VhfHandle, &pDeviceContext->VhfMouseReportPacket);
}

NTSTATUS
PrepareKeyboardReport(PDEVICE_CONTEXT pDeviceContext, PGAMEPAD_REPORT report) {
    WORD buttons = report->buttons; //i gotta make a copy so i can do le buttons shit for my keyboard

    KEYBOARD_REPORT vhfReport;
    RtlZeroMemory(&vhfReport, KEYBOARD_REPORT_SIZE);
    volatile WORD andop = 0x80; //starpower
    volatile WORD andop2 = 0x100; //strum down
    volatile BYTE shift = 5;
    volatile BYTE shift2 = 7;
    vhfReport.id = 3;
    //vhfReport.modifierKeys = (((BYTE)report->buttons) & andop) >> shift; //strum up (wait no that's not the right key lol)
    vhfReport.modifierKeys = (BYTE)(
        //starpower -> left alt
        (((report->buttons) & andop) >> shift) |
        //strum down -> left shift
        (((report->buttons) & andop2) >> shift2)
    );

    BYTE keyMap[] = {
        0x04,   //'A'
        0x16,   //'S'
        0x09,   //'F'
        0x0A,   //'G'
        0x0B,   //'H'
        0x2B,   //'Tab'
        0x28,   //'Enter'
        0x00,   //NULL
        0x2B,   //'Tab'
        0x00,
        0x00,
        0x00,
        0x00,
        0x00,
        0x00,
        0x00,
    };

    /*for (int i = 0; i < MAX_KEYS; i++) {
        if (buttons) {
            for (int j = 0; j < 16; j++) {
                WORD bitval = 1 << j;
                if (bitval & buttons) {
                    vhfReport.keys[i] = keyMap[j];
                    buttons ^= bitval; //clear bit
                    break;
                }
            }
        }
        else {
            break;
        }
    }*/
    if (buttons) {
        int i = 0;
        for (int j = 0; j < 16; j++) {
            if (i >= MAX_KEYS) {
                break;
            }
            WORD bitval = 1 << j;
            if (bitval & buttons) {
                vhfReport.keys[i] = keyMap[j];
                buttons ^= bitval; //clear bit
                i++;
            }
        }
    }
    memcpy(&pDeviceContext->VhfKeyboardReport, &vhfReport, KEYBOARD_REPORT_SIZE);
    return VhfReadReportSubmit(pDeviceContext->VhfHandle, &pDeviceContext->VhfKeyboardReportPacket);
}

VOID
VHIDEvtUsbTargetPipeReadComplete(
    _In_
    WDFUSBPIPE Pipe,
    _In_
    WDFMEMORY Buffer,
    _In_
    size_t NumBytesTransferred, //not including header!
    _In_
    WDFCONTEXT Context
) {
    UNREFERENCED_PARAMETER(Pipe);

    PDEVICE_CONTEXT pDeviceContext = (PDEVICE_CONTEXT)Context;

    //https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdfusb/nc-wdfusb-evt_wdf_usb_reader_completion_routine
    //PAGED_CODE() //uhhh the irql is typically DISPATCH_LEVEL so it should not be paged! https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/managing-hardware-priorities#:~:text=If%20a%20routine%20running%20at%20IRQL%20greater%20than%20APC_LEVEL%20causes%20a%20page%20fault%2C%20it%27s%20a%20fatal%20error.
    //yep the docs say it in a different place
    //https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/when-should-code-and-data-be-pageable-

    __int3();

    size_t bytes; //including the header!
    PVOID mem = WdfMemoryGetBuffer(Buffer, &bytes);
    if (mem != NULL && NumBytesTransferred != 0) {
        size_t headerLength = pDeviceContext->resHeaderLength;
        //if (headerLength != (bytes - NumBytesTransferred)) {
        //    headerLength = bytes - NumBytesTransferred;
        //    KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "Header length mismatch? according to my calculations it should be %llu bytes instead of the %llu bytes from pDeviceContext!\n", headerLength, pDeviceContext->resHeaderLength));
        //}
        //volatile UCHAR reportId = 0;
        volatile size_t doctorRuntime = 0;
        PGAMEPAD_REPORT report = (PGAMEPAD_REPORT)((ULONG_PTR)mem + (headerLength - doctorRuntime));
        //HID_XFER_PACKET packet;
        
        //pDeviceContext->VhfHidReport.reportId = reportId;
        //CreateFile('\Device\MyDevice', GENERIC_WRITE, 0, nil, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
        //HID_XFER_PACKET packet;
        //packet.reportBuffer = (PUCHAR)&vhfReport;
        //packet.reportBufferLen = sizeof(vhfReport);
        //packet.reportId = reportId;
        NTSTATUS status;
        if (pDeviceContext->mode == GAMEPAD_MODE) {
            status = PrepareGamepadReport(pDeviceContext, report);
        }
        else if(pDeviceContext->mode == MOUSE_MODE) {
            status = PrepareMouseReport(pDeviceContext, report);
        }
        else if (pDeviceContext->mode == KEYBOARD_MODE) {
            status = PrepareKeyboardReport(pDeviceContext, report);
        }
        else {
            status = PrepareGamepadReport(pDeviceContext, report);
            if (!NT_SUCCESS(status)) {
                KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "VHID: PrepareGamepadReport (VhfReadReportSubmit) failed 0x%x!\n", status));
            }
            status = PrepareMouseReport(pDeviceContext, report);
            if (!NT_SUCCESS(status)) {
                KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "VHID: PrepareMouseReport (VhfReadReportSubmit) failed 0x%x!\n", status));
            }
            if (pDeviceContext->mode >= ISOCRONOUS_MODE) {
                status = PrepareKeyboardReport(pDeviceContext, report);
                if (!NT_SUCCESS(status)) {
                    KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "VHID: PrepareKeyboardReport (VhfReadReportSubmit) failed 0x%x!\n", status));
                }
            }
            status = STATUS_SUCCESS; //;to stop it from printing again below.
        }
        if (!NT_SUCCESS(status)) {
            KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "VHID: VhfReadReportSubmit failed 0x%x!\n", status));
        }
        //if ((report->buttons & 1) == 1) {
        //    KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "GREEN FN\n"));
        //}
        //else {
            //KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "VHID: INTERRUPT IN -> 0x%p [" WORD_TO_BINARY_PATTERN "] (%llu == %llu)\n", mem, WORD_TO_BINARY(report->buttons), NumBytesTransferred, bytes));
            //                                                                                                                  why is PUGAMEPAD_REPORT not working?
            //KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "VHID: INTERRUPT IN -> 0x%p [%#04x|%#04x] (%llu == %llu)\n", mem, ((PUGAMEPAD_REPORT)report)->buttons.word.high, ((PUGAMEPAD_REPORT)report)->buttons.word.low, NumBytesTransferred, bytes));
            KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "VHID: INTERRUPT IN -> 0x%p [%#04x|%#04x] (%llu == %llu)\n", mem, (BYTE)report->buttons, (BYTE)(report->buttons >> 8), NumBytesTransferred, bytes));
        //}
    }
    else {
        KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "VHID: NULL INTERRUPT IN -> 0x%p (%llu == %llu)\n", mem, NumBytesTransferred, bytes));
    }
}

VOID
VHIDEvtDeviceContextCleanup(
    _In_ WDFOBJECT DeviceObject
)
/*++
Routine Description:

    Free all the resources allocated in EvtDeviceAdd.

Arguments:

    DeviceObject - handle to a WDF Device object.

Return Value:

    VOID.

--*/
{
    PAGED_CODE();

    PDEVICE_CONTEXT deviceContext = DeviceGetContext(DeviceObject);

    if (deviceContext->VhfHandle != WDF_NO_HANDLE) {
        VhfDelete(deviceContext->VhfHandle, TRUE);
    }
}